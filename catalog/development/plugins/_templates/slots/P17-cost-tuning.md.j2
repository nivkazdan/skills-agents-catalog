---
name: {{ company }}-cost-tuning
description: |
  Optimize {{ display_name }} costs through tier selection, sampling, and usage monitoring.
  Use when analyzing {{ display_name }} billing, reducing API costs,
  or implementing usage monitoring and budget alerts.
  Trigger with phrases like "{{ company }} cost", "{{ company }} billing",
  "reduce {{ company }} costs", "{{ company }} pricing", "{{ company }} expensive", "{{ company }} budget".
allowed-tools: Read, Grep
version: 1.0.0
license: MIT
author: Jeremy Longshore <jeremy@intentsolutions.io>
---

# {{ display_name }} Cost Tuning

## Overview
Optimize {{ display_name }} costs through smart tier selection, sampling, and usage monitoring.

## Prerequisites
- Access to {{ display_name }} billing dashboard
- Understanding of current usage patterns
- Database for usage tracking (optional)
- Alerting system configured (optional)

## Pricing Tiers

| Tier | Monthly Cost | Included | Overage |
|------|-------------|----------|---------|
| {{ tier_1_name | default('Free') }} | ${{ tier_1_cost | default('0') }} | {{ tier_1_included | default('1,000 requests') }} | N/A |
| {{ tier_2_name | default('Pro') }} | ${{ tier_2_cost | default('99') }} | {{ tier_2_included | default('100,000 requests') }} | ${{ tier_2_overage | default('0.001') }}/request |
| {{ tier_3_name | default('Enterprise') }} | Custom | Unlimited | Volume discounts |

## Cost Estimation

```typescript
interface UsageEstimate {
  requestsPerMonth: number;
  tier: string;
  estimatedCost: number;
  recommendation?: string;
}

function estimate{{ display_name }}Cost(requestsPerMonth: number): UsageEstimate {
  if (requestsPerMonth <= {{ tier_1_limit | default('1000') }}) {
    return { requestsPerMonth, tier: 'Free', estimatedCost: 0 };
  }

  if (requestsPerMonth <= {{ tier_2_limit | default('100000') }}) {
    return { requestsPerMonth, tier: 'Pro', estimatedCost: {{ tier_2_cost | default('99') }} };
  }

  const proOverage = (requestsPerMonth - {{ tier_2_limit | default('100000') }}) * {{ tier_2_overage_rate | default('0.001') }};
  const proCost = {{ tier_2_cost | default('99') }} + proOverage;

  return {
    requestsPerMonth,
    tier: 'Pro (with overage)',
    estimatedCost: proCost,
    recommendation: proCost > {{ enterprise_threshold | default('500') }}
      ? 'Consider Enterprise tier for volume discounts'
      : undefined,
  };
}
```

## Usage Monitoring

```typescript
class {{ display_name }}UsageMonitor {
  private requestCount = 0;
  private bytesTransferred = 0;
  private alertThreshold: number;

  constructor(monthlyBudget: number) {
    this.alertThreshold = monthlyBudget * 0.8; // 80% warning
  }

  track(request: { bytes: number }) {
    this.requestCount++;
    this.bytesTransferred += request.bytes;

    if (this.estimatedCost() > this.alertThreshold) {
      this.sendAlert('Approaching {{ display_name }} budget limit');
    }
  }

  estimatedCost(): number {
    return estimate{{ display_name }}Cost(this.requestCount).estimatedCost;
  }

  private sendAlert(message: string) {
    // Send to Slack, email, PagerDuty, etc.
  }
}
```

## Cost Reduction Strategies

### Step 1: Request Sampling
```typescript
function shouldSample(samplingRate = 0.1): boolean {
  return Math.random() < samplingRate;
}

// Use for non-critical telemetry
if (shouldSample(0.1)) { // 10% sample
  await {{ company }}Client.trackEvent(event);
}
```

### Step 2: Batching Requests
```typescript
// Instead of N individual calls
await Promise.all(ids.map(id => {{ company }}Client.get(id)));

// Use batch endpoint (1 call)
await {{ company }}Client.batchGet(ids);
```

### Step 3: Caching (from P16)
- Cache frequently accessed data
- Use cache invalidation webhooks
- Set appropriate TTLs

### Step 4: Compression
```typescript
const client = new {{ client_class | default(display_name + 'Client') }}({
  compression: true, // Enable gzip
});
```

## Budget Alerts

```bash
# Set up billing alerts in {{ display_name }} dashboard
# Or use API if available:
{{ billing_api_example | default('# Check ' + display_name + ' documentation for billing APIs') }}
```

## Cost Dashboard Query

```sql
-- If tracking usage in your database
SELECT
  DATE_TRUNC('day', created_at) as date,
  COUNT(*) as requests,
  SUM(response_bytes) as bytes,
  COUNT(*) * {{ cost_per_request | default('0.001') }} as estimated_cost
FROM {{ company }}_api_logs
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY 1
ORDER BY 1;
```

## Instructions

### Step 1: Analyze Current Usage
Review {{ display_name }} dashboard for usage patterns and costs.

### Step 2: Select Optimal Tier
Use the cost estimation function to find the right tier.

### Step 3: Implement Monitoring
Add usage tracking to catch budget overruns early.

### Step 4: Apply Optimizations
Enable batching, caching, and sampling where appropriate.

## Output
- Optimized tier selection
- Usage monitoring implemented
- Budget alerts configured
- Cost reduction strategies applied

## Error Handling
| Issue | Cause | Solution |
|-------|-------|----------|
| Unexpected charges | Untracked usage | Implement monitoring |
| Overage fees | Wrong tier | Upgrade tier |
| Budget exceeded | No alerts | Set up alerts |
| Inefficient usage | No batching | Enable batch requests |

## Examples

### Quick Cost Check
```typescript
// Estimate monthly cost for your usage
const estimate = estimate{{ display_name }}Cost(yourMonthlyRequests);
console.log(`Tier: ${estimate.tier}, Cost: $${estimate.estimatedCost}`);
if (estimate.recommendation) {
  console.log(`ðŸ’¡ ${estimate.recommendation}`);
}
```

## Resources
- [{{ display_name }} Pricing]({{ pricing_url | default('https://' + company + '.com/pricing') }})
- [{{ display_name }} Billing Dashboard]({{ dashboard_url | default('https://dashboard.' + company + '.com') }}/billing)

## Next Steps
For architecture patterns, see `{{ company }}-reference-architecture`.
